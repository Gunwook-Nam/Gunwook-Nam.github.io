---
layout: page
title: Linux Shell 분류와 실행
description: >
  Bourne Shell과 C Shell의 차이, Shebang의 역할, 그리고 스크립트 실행 방식(source, ., ./)
hide_description: false
sitemap: false
---

# 1. Bourne Shell과 C Shell의 분류

리눅스 쉘은 크게 **Bourne Shell (sh)** 계열과 **C Shell (csh)** 계열로 나뉜다. 두 계열은 문법과 환경 변수 설정 방식에서 차이를 보인다.

## Bourne Shell 계열 (Bash, Zsh)
유닉스의 표준인 `sh`를 계승한 계열이다. 현재 리눅스와 macOS에서 기본적으로 사용하는 쉘이 대부분 여기에 속한다.

### Bash (Bourne Again Shell)
Bourne Shell을 대체하기 위해 만들어진 쉘로, 대부분의 리눅스 배포판에서 기본 쉘로 사용된다.

- **특징**
  - POSIX `sh`와 높은 호환성을 유지한다.
  - 제어문(`if`, `for`, `while`)과 함수 문법이 단순하고 직관적이다.
  - 히스토리, 명령 줄 편집(Emacs/Vim 모드), 간단한 자동완성 등 기본 기능을 제공한다.
- **장점**
  - 거의 모든 리눅스 시스템에 기본 설치되어 있어, 스크립트 배포 시 의존성이 적다.
  - POSIX 스타일의 스크립트와 Bash 확장 문법을 모두 사용할 수 있어 유연하다.
  - 서버, HPC 클러스터 등에서 사실상의 표준으로 취급된다.
- **단점**
  - 기능 면에서 Zsh에 비해 상호작용 환경이 단순하다.

### Zsh (Z Shell)
Bash와 호환되면서도, 상호작용 환경(interactive shell)을 강화한 쉘이다. 현재 macOS의 기본 로그인 쉘이다.

- **특징**
  - 강력한 자동완성 및 경로 확장, 철자 교정(spell checking) 기능을 제공한다.
  - 프롬프트 커스터마이징, 플러그인 프레임워크(Oh My Zsh 등)를 통해 환경 구성이 쉽다.
  - 대부분의 Bash 스크립트를 별도 수정 없이 실행할 수 있다.
- **장점**
  - 긴 명령을 자주 입력하는 상호작용 작업에서 생산성을 크게 높여준다.
  - 다양한 테마와 플러그인을 통해 실험적으로 환경을 꾸미기 좋다.
  - 배열, 연관 배열 등 고급 기능을 제공해 복잡한 스크립트 작성에도 유리하다.
- **단점**
  - 기본 설치가 아닌 시스템(특히 서버, HPC)에서는 별도 설치가 필요하다.
  - 플러그인과 설정이 많아질수록 초기 로딩 속도가 느려질 수 있다.

## C Shell 계열 (Csh, Tcsh)
Bourne 계열과 달리, C 언어의 문법을 참고해 설계된 쉘이다. 현재는 상호작용용으로 일부 사용되지만, 새로운 스크립트 작성에는 권장되지 않는 경우가 많다.

### Csh (C Shell)
초기의 유닉스 환경에서 C 언어에 익숙한 사용자를 위해 만들어진 쉘이다.

- **특징**
  - `if (expr) then ... endif` 와 같은 C 언어와 유사한 문법을 사용한다.
  - 히스토리 확장(`!$`, `!!` 등)을 비교적 일찍 도입했다.
- **장점**
  - C 스타일 문법에 익숙한 사용자에게는 조건문과 반복문이 직관적으로 느껴질 수 있다.
  - 오래된 유닉스 시스템 문서나 예제에서 자주 등장한다.
- **단점**
  - 에러 처리와 I/O 리다이렉션 문법이 일관성이 떨어진다는 비판이 많다.
  - 함수 개념이 부족하고, 스크립트 언어로 사용할 때 제약이 크다.
  - 현재는 거의 사용되지 않고, 대부분 Tcsh로 대체되었다.

### Tcsh (TENEX C Shell)
Csh를 확장한 쉘로, 실제로 "C Shell 계열"을 말할 때 현대 환경에서는 거의 Tcsh를 의미한다.

- **특징**
  - 명령 줄 편집, 자동완성, 히스토리 탐색 등 상호작용 기능이 Csh보다 강화되어 있다.
  - 전통적인 Csh 문법을 그대로 유지하면서 추가 기능을 제공한다.
- **장점**
  - 오래된 계산 화학 소프트웨어(Gaussian, Q-Chem, 일부 Amber 스크립트 등)가 Tcsh 환경을 가정하고 배포된 경우가 많다.
  - Csh 기반의 기존 스크립트를 수정 없이 그대로 사용할 수 있다.
- **단점**
  - Bourne 계열에 비해 스크립트 문법이 복잡하고, 예외 처리에 취약하다는 평가가 많다.
  - 새로운 스크립트를 작성할 때는 유지보수성과 문법의 일관성 측면에서 Bash/Zsh에 비해 불리하다.
  - POSIX 표준과 직접적으로 맞지 않아, 이식성을 중시하는 환경에는 적합하지 않다.


# 2. Shebang (#!)

스크립트 파일의 첫 줄에 작성하는 `#!/bin/bash`와 같은 코드를 **Shebang**이라고 한다.

## 2.1 Shebang의 역할과 동작 원리

- **역할**
  - 커널에게 이 파일을 어느 인터프리터로 실행해야 하는지를 알려준다.
  - 사용자가 `./script.sh`처럼 실행했을 때, 직접 쉘을 지정하지 않아도 된다.
- **동작 원리**
  - 실행 요청이 들어오면 커널이 첫 줄을 읽어 `#!` 뒤의 경로(예: `/bin/bash`)를 해석한다.
  - 해당 프로그램을 새 프로세스로 실행하고, 스크립트 파일의 나머지 내용을 그 프로그램의 입력으로 넘긴다.
  - Shebang이 없으면, 현재 사용 중인 쉘이 단순 텍스트로 해석하거나, 실행을 거부할 수 있다.

## 2.2 자주 쓰는 Shebang 예시

- `#!/bin/bash`
  - 리눅스 환경에서 가장 흔하게 사용하는 형태다.
  - 시스템에 설치된 기본 Bash를 사용하므로, 대부분의 배포판에서 그대로 동작한다.
- `#!/usr/bin/env python`
  - `PATH` 환경 변수에서 `python` 실행 파일을 찾아 사용한다.
  - 가상환경(venv, conda 등)을 사용할 때 현재 활성화된 환경의 파이썬을 사용하게 할 수 있다.
- `#!/bin/tcsh`
  - 스크립트를 Tcsh 문법으로 해석하도록 강제한다.
  - 로그인 쉘이 Bash/Zsh라 하더라도, 이 스크립트는 Tcsh 규칙을 따른다.

## 2.3 주의할 점

- 스크립트가 여러 시스템에서 사용될 가능성이 있다면, 존재 여부가 불확실한 경로(`/usr/local/bin/...` 등)는 피하는 것이 좋다.
- 파이썬, 루비처럼 여러 버전이 공존하는 언어는 `#!/usr/bin/env python3`처럼 버전을 명시하는 것이 안전하다.
- 파일 인코딩이나 줄 끝 형식(CRLF vs LF)이 잘못되어 Shebang 줄 앞에 보이지 않는 문자가 들어가면, 커널이 Shebang을 제대로 인식하지 못할 수 있다.


# 3. 스크립트 실행 방식

스크립트 실행 방식은 **새 프로세스를 만드는지 여부**와 **어떤 쉘로 해석할지**에 따라 나뉜다.

## 3.1 Subshell 실행 (`./script.sh`, `bash script.sh`, `zsh script.sh`)

  - 현재 쉘이 **자식 프로세스(Subshell)**를 하나 만든 뒤, 그 안에서 스크립트를 실행한다.
  - 스크립트가 끝나면 자식 프로세스가 종료되고, 부모 쉘의 상태는 그대로 유지된다.

- **특징과 용도**
  - 스크립트 안에서 변수 값을 바꾸거나 `cd`로 디렉토리를 옮겨도, 부모 쉘에는 영향을 주지 않는다.
  - 독립적인 작은 프로그램처럼 동작하므로, 일반적인 명령형 스크립트나 배치 작업에 적합하다.

- **`./script.sh`**
  - 파일에 실행 권한(`chmod +x script.sh`)을 주고 `./script.sh`로 실행한다.
  - Shebang에 적힌 인터프리터(예: `#!/bin/bash`, `#!/bin/tcsh`)가 실제로 스크립트를 해석한다.
  - 현재 로그인 쉘이 무엇이든, Shebang이 우선한다.

- **`bash script.sh`, `zsh script.sh`**
  - Shebang과 관계없이, 명시한 인터프리터가 스크립트를 해석한다.
  - 예를 들어, 파일 첫 줄이 `#!/bin/sh`여도 `bash script.sh`로 실행하면 bash 규칙을 따른다.

## 3.2 Current Shell 실행 (`source`, `.`)

  - `source script.sh` 또는 `. script.sh`로 실행한다.
  - 자식 프로세스를 만들지 않고, **현재 쉘**이 스크립트 내용을 그대로 읽어 한 줄씩 실행한다.

- **특징과 용도**
  - 스크립트 안에서 설정한 환경 변수, `cd`로 변경한 현재 디렉토리 등이 **지금 사용 중인 쉘에 그대로 남는다.**
  - `conda activate`처럼 환경 변수를 수정해야 하는 명령.
  - `.bashrc`, `.zshrc`와 같은 설정 파일을 다시 적용할 때.

- **`source`와 `.` (점)의 차이**
  - `source`
    - Bash, Zsh, Tcsh 등에서 지원하는 명령어다.
    - 의미가 직관적이어서 사람이 읽기 편하다.
  - `.` (점)
    - **POSIX 표준**에서 정의된 방식이다.
    - `sh`처럼 최소한의 기능만 가진 쉘에서는 `source`가 없고, `.`만 사용할 수 있다.
  - 정리하면, 호환성을 중시하면 `. script.sh`를, 가독성을 중시하면 `source script.sh`를 사용하는 식으로 선택할 수 있다.

---

# 4. POSIX 표준과 호환성

**POSIX(Portable Operating System Interface)**는 유닉스 계열 운영체제에서 공통으로 지켜야 할 최소한의 규칙을 정해 둔 표준이다.

## 4.1 POSIX 문법을 언제 고려할지

- **sh 계열 쉘의 공통 분모**
  - Bash와 Zsh는 POSIX에서 정의한 `sh` 문법을 대부분 지원한다.
  - POSIX 문법만 사용하면, `bash`, `zsh`, `/bin/sh` 중 어느 것으로 실행해도 동작이 크게 달라지지 않는다.

- **배포 범위에 따른 선택 기준**
  - 한두 대의 머신에서만 쓰는 개인용 스크립트라면 Bash/Zsh 고유 기능을 써도 된다.
  - 여러 서버, 여러 OS에 배포하는 스크립트라면 POSIX 문법만 사용하는 것이 안전하다.

- **코드 읽기와 유지보수**
  - POSIX 문법 위주로 작성된 스크립트는 문법이 단순해, 다른 사람이 읽고 이해하기 쉽다.
  - Bash/Zsh 확장 기능에 많이 의존한 스크립트는, 다른 쉘 환경에서 문제를 재현하고 분석하기가 어렵다.

- **tcsh와의 관계**
  - Tcsh는 C Shell 계열로, POSIX `sh` 표준의 대상이 아니다.
  - Tcsh 스크립트는 POSIX 호환 스크립트가 아니라, Tcsh 전용 스크립트로 보는 것이 자연스럽다.

## 4.2 Shebang 선택과 문법 선택 기준

- **여러 환경에 배포되는 공용 스크립트**
  - Shebang은 `#!/bin/sh`처럼 sh 계열로 지정한다.
  - 조건문, 반복문, 변수 치환은 POSIX `sh`에서 정의한 기본 문법만 사용한다.
  - 배열, 연관 배열, `[[ ... ]]`, 프로세스 치환(`<()`) 등은 사용하지 않는다.

- **bash 또는 zsh 전용 스크립트**
  - Shebang은 `#!/bin/bash` 또는 `#!/bin/zsh`처럼 실제로 의존하는 쉘을 명시한다.
  - 필요한 경우 해당 쉘의 확장 기능을 사용하되, 다른 쉘과의 호환성은 기대하지 않는다.

- **tcsh 스크립트**
  - Shebang은 `#!/bin/tcsh`를 사용한다.
  - POSIX와는 별도의 스크립트 세계로 생각하고, Tcsh 문법에 맞춰 관리한다.

---

# 요약

| 구분 | Bourne (Bash/Zsh) | C Shell (Tcsh) |
| :--- | :--- | :--- |
| **환경 변수** | `export VAR=val` | `setenv VAR val` |
| **Shebang 예시** | `#!/bin/bash`, `#!/usr/bin/env bash` | `#!/bin/tcsh` |
| **설정 파일 반영** | `source file`, `. file` | `source file` |
| **대표 사용 맥락** | 리눅스/맥 기본 쉘, 일반 연구 및 서버 | 계산 화학 및 유닉스 스크립트 |
